---
title:  "DuomenÅ³ tinkamumo patvirtinimo / redagavimo / Ä¯raÅ¡ymo Å¾iniÅ³ vidiniai mokymai (III)"
author: "Lietuvos Statistika"
output: 
   learnr::tutorial:
       theme: "cerulean"
       language: 
        en:
         button:
           nexttopic: Pirmyn
           previoustopic: Atgal
           runcode: Vykdyti kodÄ…
           hint: UÅ¾uomina
           hint_plural: UÅ¾uominos
           hintnext: Kita uÅ¾uomina
           hintprev: Atgal
           solution: Sprendimas
           copyclipboard: Kopijuoti
           startover: IÅ¡ naujo
           continue: TÄ™sti
           submitanswer: Pateikti atsakymÄ…
           questiontryagain: Bandyti iÅ¡ naujo
         text:
           startover: Perkrauti
           areyousure: Esate tikri, kad norite perkrauti esamÄ… programÄ…?
           youmustcomplete: Turite pabaigti 
           exercise: uÅ¾duotis
           exercise_plural: uÅ¾duotys
           inthissection: Å¡ioje dalyje norÄ—dami tÄ™sti. 
           code: Kodas
           quiz: Klausimas
progressive: true
allow_skip: true
runtime: shiny_prerendered
---


```{r setup, include=FALSE}


r = getOption("repos")
r["CRAN"] = "http://cran.us.r-project.org"
options(repos = r)


install.packages("rmarkdown")
install.packages("sortable")
install.packages("openxlsx")
install.packages("scales")
install.packages("readxl")
install.packages("tidyverse")
install.packages("remotes")
install.packages("fdm2id")
install.packages("plyr")
install.packages("SeleMix")
remotes::install_github("rstudio/gradethis")
remotes::install_github("rstudio/learnr")


library(learnr)
library(gradethis)
library(rmarkdown)
library(sortable)
library(openxlsx)
library(scales)
library(readxl)
library(tidyverse) 
library(fdm2id)
library(plyr)
library(SeleMix)
knitr::opts_chunk$set(echo = FALSE)
tutorial_options(
  exercise.checker = gradethis::grade_learnr, 
  exercise.startover = TRUE
)

setwd("~/SwedenStuff/Lietuvos Statistika/LS - 3 skaidres/LS - 3 skaidres")
# Create objects use throughout tutorial:
# Read in data as `duomenys`
duomenys <- read_excel("Duomenys.xlsx")
names(duomenys) <- c("kodas9", "evrk2", "imtis", "viso", "val", "viso_prm_ket", "viso_pr_ket", "pvm", "DSK")
duomenys <- duomenys[!is.na(duomenys$viso) & !(is.na(duomenys$pvm)),]
kuko <- cooks.distance(lm(viso ~ val, data = duomenys))
labels_kuko <- 1:sum(!is.na(duomenys$viso) & !is.na(duomenys$val))
labels_kuko[which(kuko < 0.2)] <- NA

duomenys1 <- read.xlsx("Duomenys1.xlsx")
names(duomenys1) <- c("kodas9", "vs2", "imtis", "viso_m1", "viso_m2", "viso_m3", "viso","val", "viso_prm_ket", "viso_pr_ket", "pvm1", "pvm2", "pvm3", "pvm", "DSK")
```

## Ä®Å¾anga

```{r, echo=FALSE, out.width="100%", fig.align = "center"}
knitr::include_graphics("images/something_new.png")  
```

```{r, echo=FALSE, out.width="10%", fig.align = "center"}
knitr::include_graphics("images/LS_logo.svg")  
```

<br>
Å ioje platformoje rasite mokymÅ³ medÅ¾iagÄ… Lietuvos Statistikos departamento viduje organizuojamiems mokymams, skirtiems tikslinÄ—ms darbuotojÅ³ grupÄ—ms. Vienas pagrindiniÅ³ Å¡iÅ³ mokymÅ³ siekiÅ³ â€“ platinti Lietuvos Statistikos darbuotojÅ³ Å¾inias ir gebÄ—jimus atlikti statistiniÅ³ duomenÅ³ tinkamumo patvirtinimÄ…, redagavimÄ…, praleistÅ³ reikÅ¡miÅ³ Ä¯raÅ¡ymÄ… naudojantis R programavimo kalba.  <br><br> TeorinÄ— mokymÅ³ medÅ¾iaga jau yra parengta skaidriÅ³ pavidalu. Å ioje platformoje turite galimybÄ™ mokytis savarankiÅ¡kai â€“ perÅ¾iÅ«rÄ—ti parengtÄ… mokymÅ³ medÅ¾iagÄ…, atlikti praktines uÅ¾duotis.
<br><br> TreÄiojoje mokymÅ³ dalyje pateikiama naudinga informacija apie:

- **Pirsono koreliacijÄ…**: ir kaip jÄ… apskaiÄiuoti paÅ¡alinus iÅ¡skirtis. <br>
- **TiesinÄ—s regresijos modeliavimÄ…**: kaip jÄ¯ atlikti ir patikrinti statistinÄ¯ reikÅ¡mingumÄ…. <br>
- **TiesinÄ—s regresijos modelio prielaidas**: bei Kuko matÄ…. <br> 
- **DaugialypÄ—s regresijos modeliavimÄ…**: kaip jÄ¯ atlikti ir patikrinti statistinÄ¯ reikÅ¡mingumÄ…. <br>
- **Pasirinktinio redagavimo metodÄ…**: ir kaip jÄ¯ apskaiÄiuoti naudojantis R. <br>
- **Hidiroglou-Berthelot metodÄ…**: ir kaip jÄ¯ apskaiÄiuoti naudojantis R.
<br><br>

#### Kaip tai veikia?

Rasite klausimÅ³ su atsakymÅ³ variantais:
```{r quiz0, warning=FALSE, echo=FALSE}
quiz(caption = "",
  question("Kiek bus 5+5?", 
           answer("15"),
           answer("10", correct = TRUE), 
           answer("11"),
           answer("100"),
           correct = "Atsakymas teisingas!", 
           incorrect = "Atsakymas neteisingas",
  submit_button = "Pateikti", 
  try_again_button = "IÅ¡ naujo",
    allow_retry = TRUE
  )
)
```

Rasite klausimÅ³, kuriuose reikalinga iÅ¡rikiuoti atsakymus pagal tam tikrÄ… eilÄ™:

```{r ranking-example, warning=FALSE, echo=FALSE}

question_rank("<br>1. 2+2 <br>
              2. 10+10 <br>
              3. 100-90 <br>
              4. 4*2",
  answer(skales <- c(
    "4",
    "20",
    "10",
    "8"),
  correct = TRUE), correct = "Teisingai!", incorrect = "Bandykite dar kartÄ…!",
  allow_retry = TRUE,
  random_answer_order = TRUE,
  submit_button = "Pateikti",
  options = sortable_options(), 
  try_again_button = "IÅ¡ naujo"
)
```


Taip pat, dirbsite su R, kur programavimo kodas veiks lyg dirbant tiesiogiai programoje. Paspauskite `Ctr+Enter` arba `Vykdyti kodÄ…` mygtukÄ…, kad Ä¯vykdytumÄ—te programÄ…. 

```{r, echo=FALSE, out.width="85%", fig.align = "center"}
knitr::include_graphics("images/code_chunk_key.png")  
```

```{r example1, exercise=TRUE, exercise.lines = 4, exercise.cap = "R kodas"}
2+2
```

Jeigu nerandate tinkamo atsakymo kodo langelyje, galite pasinaudoti `UÅ¾uomina` , arba pasitikrinti atsakymÄ… `Atsakymas` mygtuku. <br><br> NepamirÅ¡kite pateikti atsakymo paspausdami `Pateikti atsakymÄ…` mygtukÄ…,  kur gausite iÅ¡samesnÄ¯ komentarÄ… apie savo kodÄ… anglÅ³ kalba. 

```{r, echo=FALSE, out.width="85%", fig.align = "center"}
knitr::include_graphics("images/code_exercise_key.png")  
```

```{r example2, exercise=TRUE, exercise.lines = 3, exercise.cap = "R kodas"}
2+2==5
```

```{r example2-hint}
Ar suma teisinga?
```

```{r example2-solution}
2+2==4
```

```{r example2-check}
gradethis::grade_code()
```

Taip pat, prieÅ¡ pradedant mokymus, svarbu nuspausti mygtukÄ… `Perkrauti` (kaip paÅ¾ymÄ—ta paveikslÄ—lyje). Tai uÅ¾tikrina, kad uÅ¾duotys yra vykdomos nuo pradÅ¾iÅ³. Å Ä¯ mygtukÄ… galite naudoti kaskart, kai norite perkrauti mokymÅ³ medÅ¾iagÄ… ir jÄ… Ä¯vykdyti iÅ¡ naujo.  

```{r, echo=FALSE, out.width="100%", fig.align = "center"}
knitr::include_graphics("images/start_over.png")  
```

#### Iliustracijos
Å i mokymÅ³ platforma iliustruota paveikslÄ—liais, kuriuos galite rasti [Å¡iuo adresu](https://github.com/allisonhorst/stats-illustrations/). Naudojant Å¡ias iliustracijas, cituokite jas taip: â€œArtwork by @allison_horstâ€.

**SÄ—kmÄ—s!**

## 1. Pirsono koreliacijos koeficientas
 
```{r, echo=FALSE, out.width="50%", fig.align = "center"}
knitr::include_graphics("images/krill_correlation.png")  
```


Pirsono koreliacijos koeficientas geriausiai Ä¯vertina tiesinÄ™ kintamÅ³jÅ³ priklausomybÄ™, kai yra patenkinta prielaida apie tÅ³ kintamÅ³jÅ³ normalumÄ…, taÄiau praktikoje jis skaiÄiuojamas ir tada, kai kintamieji nÄ—ra pasiskirstÄ™ normaliai. 

Ä® sistemÄ… tebÄ—ra importuota duomenÅ³ lentelÄ— pavadinimu `duomenys` iÅ¡ praÄ—jusiojo mokymÅ³ bloko. <br>

**Kintamieji:**

- `kodas9`: Ä¯monÄ—s kodas
- `evrk2`: Ä¯monÄ—s ekonominÄ—s veiklos rÅ«Å¡ies kodas
- `imtis`: patekimo Ä¯ imtÄ¯ indikatorius
- `viso`: bendra ataskaitinio laikotarpio Ä¯monÄ—s apyvarta
- `val`:  visos ataskaitinÄ¯ laikotarpÄ¯ dirbtos Ä¯monÄ—s darbuotojÅ³ valandos
- `viso_prm_ket`: bendra praeitÅ³ metÅ³ atitinkamo laikotarpio Ä¯monÄ—s apyvarta
- `viso_pr_ket`: bendra praeito laikotarpio Ä¯monÄ—s apyvarta
- `pvm`: Ä¯monÄ—s apyvarta pagal PVM ataskaitÅ³ duomenis
- `DSK`: vidutinis ataskaitinio laikotarpio Ä¯monÄ—s darbuotojÅ³ skaiÄius


#### 1.1. ApskaiÄiuokite Pirsono ("Pearson") koreliacijos koeficientÄ… tarp `duomenys$pvm` ir `duomenys$viso` naudodamiesi `cor()` funkcija.
```{r Pearson-correlation, exercise=TRUE, exercise.cap = "R kodas", warning=FALSE, echo=FALSE}
cor(___$___, ___$___, method = "___", use = "pairwise.complete.obs")
```

```{r Pearson-correlation-hint}
NepamirÅ¡kite po kintamÅ³jÅ³ Ä¯vesti metodÄ…, t.y. method = "pearson".
```

```{r Pearson-correlation-solution}
cor(duomenys$pvm, duomenys$viso, method = "pearson", use = "pairwise.complete.obs")
```

```{r Pearson-correlation-check}
grade_this({
  if (identical(.result, cor(duomenys$pvm, duomenys$viso, method = "pearson", use = "pairwise.complete.obs"))) {
    pass("Puiku!")
  }
  if (!identical(.result, cor(duomenys$pvm, duomenys$viso, method = "pearson", use = "pairwise.complete.obs"))) {
    fail("TikÄ—jomÄ—s kito varianto! Pabandykite darkart.")
  }
})
```

#### 1.2. Ä®vykdykite Å¾emiau nurodytus veiksmus

**1.** PaÅ¡alinkite iÅ¡skirtis `pvm` ir `viso` stulpeliuose su Å¾emiau nurodytu kodu (realioje situacijoje tokias iÅ¡skirtis reikÄ—tÅ³ paÅ¾ymÄ—ti tikrinimui) **(1 ir 2 kodo eilutÄ—s)**.<br>**2.** Vizualiai patikrinkite, ar tebÄ—ra iÅ¡siskirianÄiÅ³ reikÅ¡miÅ³. **(3 kodo eilutÄ—)**
```{r redagavimas, exercise=TRUE, exercise.cap = "R kodas", warning=FALSE, echo=FALSE}
duomenys <- duomenys[-c(which.max(duomenys$___)),]
duomenys <- duomenys[-c(which.max(duomenys$___)),]
plot(duomenys[,c("___","___")], ylab = "Statistinio tyrimo apyvarta", xlab = "PVM apyvarta")
```

```{r redagavimas-solution}
duomenys <- duomenys[-c(which.max(duomenys$pvm)),]
duomenys <- duomenys[-c(which.max(duomenys$viso)),]
plot(duomenys[,c("pvm","viso")], ylab = "Statistinio tyrimo apyvarta", xlab = "PVM apyvarta")
```

```{r redagavimas-check}
gradethis::grade_code()
```


**3.** ApskaiÄiuokite Pirsono koreliacijos koeficientÄ… tarp `pvm` ir `viso` dar kartÄ…. **(4 kodo eilutÄ—)**
```{r redagavimas2-setup}
duomenys <- duomenys[-c(which.max(duomenys$pvm)),]
duomenys <- duomenys[-c(which.max(duomenys$viso)),]
plot(duomenys[,c("pvm","viso")], ylab = "Statistinio tyrimo apyvarta", xlab = "PVM apyvarta")
```

```{r redagavimas2, exercise=TRUE, exercise.cap = "R kodas", warning=FALSE, echo=FALSE}

cor(___$___, ___$___, method = "___", use = "pairwise.complete.obs")


```

```{r redagavimas2-solution}
cor(duomenys$pvm, duomenys$viso, method = "pearson", use = "pairwise.complete.obs")
```

```{r redagavimas2-check}
grade_this({
  if (identical(.result, cor(duomenys$pvm, duomenys$viso, method = "pearson", use = "pairwise.complete.obs"))) {
    pass("Puiku!")
  }
  if (!identical(.result, cor(duomenys$pvm, duomenys$viso, method = "pearson", use = "pairwise.complete.obs"))) {
    fail("TikÄ—jomÄ—s kito varianto! Pabandykite darkart.")
  }
})
```

#### 1.3. Koks buvo *1.2.* Pirsono koreliacijos koeficientas po iÅ¡skirÄiÅ³ paÅ¡alinimo?
```{r quiz1, warning=FALSE, echo=FALSE}
quiz(caption = "",
  question("", 
           answer("0.47"),
           answer("0.94", correct = TRUE), 
           correct = "Atsakymas teisingas! PaÅ¡alinus iÅ¡skirtis `pvm` ir `viso` stulpeliuose koreliacija tapo dvigubai stipresnÄ—.", 
           incorrect = "Bandykite dar kartÄ….",
           allow_retry = TRUE,
  submit_button = "Pateikti", 
  try_again_button = "IÅ¡ naujo"
  )
)
```

Jei turime maÅ¾ai stebiniÅ³ arba turime ranginius kintamuosius, siÅ«loma taikyti Spirmeno (Spearman) koreliacijos koeficiento Ä¯vertÄ¯ $r_{s}(x,y)$.<br> Spirmano koreliacijos koeficientas skaiÄiuojamas pakeiÄiant `method` funkcijÄ… iÅ¡ `pearson` Ä¯ `spearman`.


<br><br>
Tiesa, nepamirÅ¡kime, kad pasitaiko ir [klaidingÅ³ koreliacijÅ³](https://www.tylervigen.com/chart-pngs/2.png): 

```{r, echo=FALSE, out.width="80%", fig.align = "center"}
knitr::include_graphics("images/spurrious_correlation.png")  
```

## 2. TiesinÄ—s regresijos modelis

```{r, echo=FALSE, out.width="50%", fig.align = "center"}
knitr::include_graphics("images/tiesine_regresija.jpg")  
```

KoreliacinÄ— analizÄ— parodo, ar dviejÅ³ kintamÅ³jÅ³ reikÅ¡mÄ—s yra susijusios ir koks tos sÄ…sajos stiprumas. Jei Å¡ito uÅ¾tenka, Å¡ioje vietoje analizÄ™ ir baigiame. Jei norime geriau suprasti Å¡iÄ… sÄ…sajÄ…, galime atlikti regresinÄ™ analizÄ™. Regresijos modelis â€“ statistinis modelis, leidÅ¾iantis vieno kintamojo reikÅ¡mes prognozuoti pagal kito kintamojo reikÅ¡mes. TiesinÄ—s regresijos modelis yra: $$ğ‘Œ_ğ‘–=ğ‘+ğ‘ğ‘¥_ğ‘–+ğ‘’_ğ‘–$$

#### 2.1. Sudarykite tiesinÄ—s regresijos modelÄ¯ `viso` bei `pvm` kintamiesiems naudodamiesi `lm()` funkcija.
```{r regresija, exercise=TRUE, exercise.cap = "R kodas", warning=FALSE, echo=FALSE}
Modelis <- __(viso ~ pvm, data = duomenys)
summary(___)
```

```{r regresija-hint}
NepamirÅ¡kite naudotis 'summary()' funkcija, kad patikrintumÄ—te 'Modelis' rezultatÄ….
```


```{r regresija-solution}
Modelis <- lm(viso ~ pvm, data = duomenys)
summary(Modelis)
```

```{r regresija-check}
grade_result(
  pass_if(~ identical(.result, summary(Modelis))),
  fail_if(~ TRUE)
)
```

Kaip vienas iÅ¡ regresijos modelio tinkamumo rodikliÅ³ - plaÄiai naudojamas determinacijos koeficientas $r^2$. Paprastosios tiesinÄ—s regresijos atveju jis sutampa su Pirsono koreliacijos koeficientu, pakeltu kvadratu. PraktiÅ¡kai taikant regresinÄ™ analizÄ™, daÅ¾niausiai reikalaujama, kad $ğ‘Ÿ^2$â‰¥0,25.


#### 2.2. Ar, nepaÅ¡alinus iÅ¡skirÄiÅ³, determinacijos koeficientas $r^2$ *2.1.* modelyje yra didesnis nei arba lygus 0.25?

```{r quiz2, echo=FALSE, warning=FALSE}
quiz(caption = "",
  question("", 
           answer("Taip"), 
           answer("Ne", correct = TRUE),
           correct = "Atsakymas teisingas!", 
           incorrect = "Bandykite dar kartÄ….",
           allow_retry = TRUE,
  submit_button = "Pateikti", 
  try_again_button = "IÅ¡ naujo"
  )
)
```

## 3. TiesinÄ—s regresijos modelio prielaidos 

```{r, echo=FALSE, out.width="70%", fig.align = "center"}
knitr::include_graphics("images/residuals_normally_distributed.jfif")  
```

#### 3.1. PaÅ¾ymÄ—kite 4 pagrindines tiesinÄ—s regresijos modelio prielaidas.
```{r quiz3, warning =FALSE, echo=FALSE}
question_checkbox(
"",
answer("PaklaidÅ³ normalumas", correct = TRUE),
answer("PaklaidÅ³ vidurkiÅ³ lygybÄ— nuliui", correct = TRUE),
answer("PaklaidÅ³ nepriklausomumas", correct = TRUE),
answer("PaklaidÅ³ dispersijÅ³ lygybÄ—", correct = TRUE),
answer("ReikÅ¡miÅ³ normalumas"),
answer("SantykinÄ— paklaida lygi nuliui"),
answer("SantykiÅ³ sumos vienodos"),
answer("SantykiÅ³ sumos skirtingos"),
    random_answer_order = TRUE,
    allow_retry = TRUE,
    try_again = "Bandykite iÅ¡ naujo",
    submit_button = "Pateikti",
    try_again_button = "IÅ¡ naujo",
    correct = "Atsakymas teisingas!", 
    incorrect = "Bandykite dar kartÄ…."
)
```

#### 3.2. Dar kartÄ… sudarykite tiesinÄ—s regresijos modelÄ¯ `viso` bei `val` kintamiesiems ir apskaiÄiuokite Kuko matÄ… naudodamiesi funcija `cookplot()`.

**Kuko matas** parodo ar duomenyse yra iÅ¡skirÄiÅ³. Kai Kuko matas $>1$, atitinkantis stebinys - iÅ¡skirtis. 
``` {r cooks-distance, exercise = TRUE, exercise.cap = "R kodas", warning = FALSE, echo = FALSE}

cookplot(lm(___ ~ ___, data = duomenys), labels = labels_kuko)
```

```{r cooks-distance-hint}
DaÅ¾niausiai iÅ¡skirtimi laikomas stebinys, kurio Kuko reikÅ¡mÄ— didesnÄ— nei 1.
```

```{r cooks-distance-solution}

cookplot(lm(viso ~ val, data = duomenys), labels = labels_kuko)
```

```{r cooks-distance-check}
gradethis::grade_code()
```

```{r quiz4, warning =FALSE, echo=FALSE}
question_checkbox(
"Pagal Kuko mato taisyklÄ™, pasirinkite visus iÅ¡siskirianÄiÅ³ reikÅ¡miÅ³ identifikacinius numerius.",
answer("218", correct = TRUE),
answer("401", correct = TRUE),
answer("677", correct = TRUE),
answer("1264", correct = TRUE),
answer("1675", correct = TRUE),
answer("3949", correct = TRUE),
answer("219"),
answer("1060"),
answer("1400"),
answer("2270"),
    random_answer_order = TRUE,
    allow_retry = TRUE,
    try_again = "Bandykite iÅ¡ naujo",
    submit_button = "Pateikti",
    try_again_button = "IÅ¡ naujo",
    correct = "Atsakymas teisingas!", 
    incorrect = "Bandykite dar kartÄ…."
)
```

#### 3.3. Kuo rÄ—mÄ—tÄ—s sprÄ™sdami apie *3.2.* paÅ¾ymÄ—tas iÅ¡siskirianÄias reikÅ¡mes?

```{r quiz5, echo=FALSE, warning=FALSE}
quiz(caption = "",
  question("", 
           answer("$D_i>1$", correct = TRUE), 
           answer("$|SR_i |>2$ arba $|SR_i |>3.4$"),
           answer("$h_i>4/n$"),
           answer("$r^2â‰¥0.25$"),
           correct = "Atsakymas teisingas!", 
           incorrect = "Bandykite dar kartÄ….",
           allow_retry = TRUE,
  submit_button = "Pateikti",
  try_again_button = "IÅ¡ naujo"
  )
)
```

## 4. DaugialypÄ—s regresijos modelis 

```{r, echo=FALSE, out.width="50%", fig.align = "center"}
knitr::include_graphics("images/multiple.png")  
```

TiesinÄ—s daugialypÄ—s regresijos modelis yra tiesinÄ—s regresijos modelio apibendrinimas, kai nepriklausomÅ³ intervaliniÅ³ kintamÅ³jÅ³ yra daugiau nei vienas.

#### 4.1. Sudarykite daugialypÄ—s regresijos modelÄ¯ prognozuodami `viso` reikÅ¡mÄ™ pagal `pvm` ir `val`  reikÅ¡mes.
```{r daugialype-regresija, exercise=TRUE, exercise.cap = "R kodas", warning=FALSE, echo=FALSE}
DaugialypisModelis <- lm(___ ~ ___ + ___, data = duomenys)

```

```{r daugialype-regresija-hint}
NepamirÅ¡kite naudotis 'summary()' funkcija, kad patikrintumÄ—te 'DaugialypisModelis' rezultatÄ….
```


```{r daugialype-regresija-solution}
DaugialypisModelis <- lm(viso ~ pvm + val, data = duomenys)
summary(DaugialypisModelis)
```

```{r daugialype-regresija-check}
gradethis::grade_code()
```

```{r quiz6, echo=FALSE, warning=FALSE}
quiz(caption = "",
  question("Ar *4.1.* modelyje pasiektas $p$ reikÅ¡mingumo lygmuo `pvm` ir `val` kintamiesiems $p<0.05$?", 
           answer("Taip", correct = TRUE), 
           answer("Ne"),
           correct = "Atsakymas teisingas!", 
           incorrect = "Bandykite dar kartÄ….",
           allow_retry = TRUE,
  submit_button = "Pateikti",
  try_again_button = "IÅ¡ naujo"
  )
)
```

## 5. Pasirinktinio redagavimo metodas

Pasirinktinis redagavimas (angl. [Selective Editing](https://www.istat.it/en/files/2013/12/jos-2013-0039.pdf)) yra paremtas idÄ—ja ieÅ¡koti tik reikÅ¡mingÅ³ klaidÅ³ duomenyse, taip sutaupant laiko ir Å¾mogiÅ¡kÅ³jÅ³ iÅ¡tekliÅ³ bei iÅ¡laikant siektinÄ… Ä¯verÄiÅ³ tikslumÄ…. Metodui taikyti naudojama statistinio paketo R biblioteka â€SeleMixâ€œ.<br><br>

```{r, echo=FALSE, out.width="70%", fig.align = "center"}
knitr::include_graphics("images/selective_editing.png")  
```

Naudokite kitÄ… duomenÅ³ lentelÄ™ pavadinimu `duomenys1`, jau importuota Ä¯ sistemÄ….<br><br>

**Kintamieji:**

- `kodas9`: Ä¯monÄ—s kodas
- `vs2`: grupÄ—s kodas
- `imtis`: patekimo Ä¯ imtÄ¯ indikatorius
- `viso_m1`: ataskaitinio laikotarpio Ä¯monÄ—s apyvarta pirmÄ… mÄ—nesÄ¯
- `viso_m2`: ataskaitinio laikotarpio Ä¯monÄ—s apyvarta antrÄ… mÄ—nesÄ¯
- `viso_m3`: ataskaitinio laikotarpio Ä¯monÄ—s apyvarta treÄiÄ… mÄ—nesÄ¯
- `viso`:  visos ataskaitinÄ¯ laikotarpÄ¯ dirbtos Ä¯monÄ—s darbuotojÅ³ valandos
- `val`: valandÅ³ skaiÄius
- `viso_prm_ket`: bendra praeitÅ³ metÅ³ atitinkamo laikotarpio Ä¯monÄ—s apyvarta
- `viso_pr_ket`: bendra praeito laikotarpio Ä¯monÄ—s apyvarta
- `pvm1`: ataskaitinio laikotarpio Ä¯monÄ—s pvm pirmÄ… mÄ—nesÄ¯
- `pvm2`: ataskaitinio laikotarpio Ä¯monÄ—s pvm antrÄ… mÄ—nesÄ¯
- `pvm3`: ataskaitinio laikotarpio Ä¯monÄ—s pvm treÄiÄ… mÄ—nesÄ¯
- `pvm`: Ä¯monÄ—s apyvarta pagal PVM ataskaitÅ³ duomenis
- `DSK`: vidutinis ataskaitinio laikotarpio Ä¯monÄ—s darbuotojÅ³ skaiÄius
 <br>

#### 5.1. Patikrinkite, ar `duomenys1` atitinka aukÅ¡Äiau nurodytus kintamÅ³jÅ³ pavadinimus su funkcija names(). 
```{r duomenys1, exercise=TRUE, exercise.cap = "R kodas", warning=FALSE, echo=FALSE}
duomenys1
```

```{r duomenys1-solution}
names(duomenys1)
```


```{r duomenys1-check}
gradethis::grade_code()
```

<br>

Pasirinktinio redagavimo metodu ieÅ¡kosime reikÅ¡mingÅ³ klaidÅ³ `viso` apyvartos duomenyse.

#### 5.2. AtidÅ¾iai perÅ¾iÅ«rÄ—kite pasirinktinio redagavimo kodÄ…. Sekite, kur paliktos tuÅ¡Äios vietos, jas uÅ¾pildykite <br> (_Kodo vykdymas gali uÅ¾trukti porÄ… minuÄiÅ³_).

```{r selective-editing1, exercise=TRUE, exercise.cap = "R kodas", exercise.timelimit = 30000, warning=FALSE, echo=FALSE}
duom <- duomenys1[complete.cases(duomenys1$___) & complete.cases(duomenys1$pvm),]# `pvm` bei `viso` kintamiesiems atrinkite Ä¯raÅ¡us be praleistÅ³ reikÅ¡miÅ³; iÅ¡saugokite naujus duomenis pavadinimu `duom`

duom <- duom[duom$pvm > 0 & duom$___ > 0,]# `pvm` bei `viso` kintamiesiems atrinkite Ä¯raÅ¡us didesnius uÅ¾ 0 (**2 eilutÄ—**); iÅ¡saugokite naujus duomenis pavadinimu `duom` 


# Suraskite kiekvienos veiklos Ä¯moniÅ³ skaiÄiÅ³
nrow_f <- function(df) length(df$viso)
nrow_df <- ddply(duom, .(vs2), nrow_f)
duom <- merge(duom, nrow_df, by = "vs2")
names(duom)

# Matematinis metodas bus taikomas veiklÅ³ grupÄ—ms, kuriose yra bent 5 Ä¯monÄ—s; 
nepateke1 <- duom[duom$V1 < 5,] # Nepatekusios Ä¯monÄ—s iÅ¡saugomos atskirai pavadinimu `nepateke1`
nepateke1 <- nepateke1[,c(2,1,3:ncol(nepateke1))]
duom <- duom[duom$V1 >= 5,] # Patekusios Ä¯monÄ—s toliau iÅ¡saugomos `duom`

names(nepateke1)[ncol(nepateke1)] <- "________" # Pabrauktose vietose, pervadinkite paskutinÄ¯ stulpelÄ¯ Ä¯ "grupes_dydis"
names(duom)[ncol(duom)] <- "_________" # Pabrauktose vietose, pervadinkite paskutinÄ¯ stulpelÄ¯ Ä¯ "grupes_dydis"


#-----KIEKVIENOS VEIKLOS T.SEL PARAMETRAS-----

library("dplyr")
library("SeleMix")

band <- function(duom) {
  # DidÅ¾iausio tikÄ—tinumo metodu Ä¯vertinami uÅ¾terÅ¡tÅ³ duomenÅ³ modelio parametrai ir 
  # pateikiami modelio tinkamumo rodikliai:
  est1 <- ml.est(y = duom$viso, x = duom$pvm, eps = 0.1)
  const <- 0
  for (i in seq(from = 0, to = 1, by = 0.001)) {
    SEi <- i # tikslumo lygmuo
    # SkaiÄiuojamos score funkcijÅ³ reikÅ¡mÄ—s ir iÅ¡skiriamos galimai reikÅ¡mingos klaidos:
    sel1 <- as.data.frame(sel.edit(y = duom$viso, ypred = est1$ypred, t.sel = SEi))
    SelEdit <- sel1$sel
    SE <- sum(SelEdit) # galimai reikÅ¡mingÅ³ klaidÅ³ skaiÄius
    proc <- round(SE/length(duom$viso)*100, digits = 2) # galimai reikÅ¡mingÅ³ klaidÅ³ procentinÄ— dalis
    const <- rbind(const, data.frame(SEi, SE, proc)) # klaidÅ³ sk. kiekvienam tikslumo lygmeniui
  }
  rib <- filter(const, const$SE > 1)
  t.sel <- max(rib$SEi) # iÅ¡renkamas didÅ¾iausias tikslumo lygmuo, su kuriuo dar randama reikÅ¡mingÅ³ klaidÅ³
  ribos <- data.frame(duom$vs2, t.sel) # didÅ¾iausias tikslumo lygmuo kiekvienai veiklai
}
ribos2 <- do.call(rbind, by(duom, duom$vs2, band))
t_sel_pvm <- data.frame(veikla = ribos2$duom.vs2, t.sel = ifelse(ribos2$t.sel == 0, 0.001, ribos2$t.sel))
t_sel_pvm <- data.frame(unique(t_sel_pvm))


#-----SKAIÄŒIAVIMAI-----

DUOM <- 0
est1 <- 0
sel1 <- 0
issk <- 0
issk2 <- 0

for(i in 1:nrow(t_sel_pvm)) {
  DUOM[i] = list(subset(duom, duom$vs2 == t_sel_pvm$veikla[i]))
  est1[i] = ml.est(y = DUOM[[i]][,"viso"], x = DUOM[[i]][,"pvm"], eps = 0.1)
  sel1[i] = list(sel.edit(y = DUOM[[i]][,"viso"], ypred = est1[[i]][,1], t.sel = t_sel_pvm[,"t.sel"][i])[,9])
  issk[i] = list(data.frame(DUOM[[i]], t_sel_pvm$t.sel[i], sel_editing1 = sel1[[i]]))
}

isskirtys_pvm <- do.call(rbind.data.frame, issk)
isskirtys_pvm$skirt_pm = round((1-(isskirtys_pvm$pvm/isskirtys_pvm$viso))*100, 1)
```

```{r selective-editing1-hint}

duom <- duomenys1[complete.cases(duomenys1$pvm) & complete.cases(duomenys1$viso),]
duom <- duom[duom$pvm > 0 & duom$viso > 0,]

nrow_f <- function(df) length(df$viso)
nrow_df <- ddply(duom, .(vs2), nrow_f)
duom <- merge(duom, nrow_df, by = "vs2")
names(duom)


nepateke1 <- duom[duom$V1 < 5,]
nepateke1 <- nepateke1[,c(2,1,3:ncol(nepateke1))]
names(nepateke1)[ncol(nepateke1)] <- "Grupes_dydis"

duom <- duom[duom$V1 >= 5,]
names(duom)[ncol(duom)] <- "Grupes_dydis"

#-----KIEKVIENOS VEIKLOS T.SEL PARAMETRAS-----

library("dplyr")

band <- function(duom) {
  # DidÅ¾iausio tikÄ—tinumo metodu Ä¯vertinami uÅ¾terÅ¡tÅ³ duomenÅ³ modelio parametrai ir 
  # pateikiami modelio tinkamumo rodikliai:
  est1 <- ml.est(y = duom$viso, x = duom$pvm, eps = 0.1)
  const <- 0
  for (i in seq(from = 0, to = 1, by = 0.001)) {
    SEi <- i # tikslumo lygmuo
    # SkaiÄiuojamos score funkcijÅ³ reikÅ¡mÄ—s ir iÅ¡skiriamos galimai reikÅ¡mingos klaidos:
    sel1 <- as.data.frame(sel.edit(y = duom$viso, ypred = est1$ypred, t.sel = SEi))
    SelEdit <- sel1$sel
    SE <- sum(SelEdit) # galimai reikÅ¡mingÅ³ klaidÅ³ skaiÄius
    proc <- round(SE/length(duom$viso)*100, digits = 2) # galimai reikÅ¡mingÅ³ klaidÅ³ procentinÄ— dalis
    const <- rbind(const, data.frame(SEi, SE, proc)) # klaidÅ³ sk. kiekvienam tikslumo lygmeniui
  }
  rib <- filter(const, const$SE > 1)
  t.sel <- max(rib$SEi) # iÅ¡renkamas didÅ¾iausias tikslumo lygmuo, su kuriuo dar randama reikÅ¡mingÅ³ klaidÅ³
  ribos <- data.frame(duom$vs2, t.sel) # didÅ¾iausias tikslumo lygmuo kiekvienai veiklai
}
ribos2 <- do.call(rbind, by(duom, duom$vs2, band))
t_sel_pvm <- data.frame(veikla = ribos2$duom.vs2, t.sel = ifelse(ribos2$t.sel == 0, 0.001, ribos2$t.sel))
t_sel_pvm <- data.frame(unique(t_sel_pvm))


#-----SKAIÄŒIAVIMAI-----

DUOM <- 0
est1 <- 0
sel1 <- 0
issk <- 0
issk2 <- 0

for(i in 1:nrow(t_sel_pvm)) {
  DUOM[i] = list(subset(duom, duom$vs2 == t_sel_pvm$veikla[i]))
  est1[i] = ml.est(y = DUOM[[i]][,"viso"], x = DUOM[[i]][,"pvm"], eps = 0.1)
  sel1[i] = list(sel.edit(y = DUOM[[i]][,"viso"], ypred = est1[[i]][,1], t.sel = t_sel_pvm[,"t.sel"][i])[,9])
  issk[i] = list(data.frame(DUOM[[i]], t_sel_pvm$t.sel[i], sel_editing1 = sel1[[i]]))
}

isskirtys_pvm <- do.call(rbind.data.frame, issk)
isskirtys_pvm$skirt_pm = round((1-(isskirtys_pvm$pvm/isskirtys_pvm$viso))*100, 1)

```

```{r selective-editing1-solution}

duom <- duomenys1[complete.cases(duomenys1$pvm) & complete.cases(duomenys1$viso),]
duom <- duom[duom$pvm > 0 & duom$viso > 0,]

nrow_f <- function(df) length(df$viso)
nrow_df <- ddply(duom, .(vs2), nrow_f)
duom <- merge(duom, nrow_df, by = "vs2")
names(duom)


nepateke1 <- duom[duom$V1 < 5,]
nepateke1 <- nepateke1[,c(2,1,3:ncol(nepateke1))]
names(nepateke1)[ncol(nepateke1)] <- "Grupes_dydis"

duom <- duom[duom$V1 >= 5,]
names(duom)[ncol(duom)] <- "Grupes_dydis"

#-----KIEKVIENOS VEIKLOS T.SEL PARAMETRAS-----

library("dplyr")

band <- function(duom) {
  # DidÅ¾iausio tikÄ—tinumo metodu Ä¯vertinami uÅ¾terÅ¡tÅ³ duomenÅ³ modelio parametrai ir 
  # pateikiami modelio tinkamumo rodikliai:
  est1 <- ml.est(y = duom$viso, x = duom$pvm, eps = 0.1)
  const <- 0
  for (i in seq(from = 0, to = 1, by = 0.001)) {
    SEi <- i # tikslumo lygmuo
    # SkaiÄiuojamos score funkcijÅ³ reikÅ¡mÄ—s ir iÅ¡skiriamos galimai reikÅ¡mingos klaidos:
    sel1 <- as.data.frame(sel.edit(y = duom$viso, ypred = est1$ypred, t.sel = SEi))
    SelEdit <- sel1$sel
    SE <- sum(SelEdit) # galimai reikÅ¡mingÅ³ klaidÅ³ skaiÄius
    proc <- round(SE/length(duom$viso)*100, digits = 2) # galimai reikÅ¡mingÅ³ klaidÅ³ procentinÄ— dalis
    const <- rbind(const, data.frame(SEi, SE, proc)) # klaidÅ³ sk. kiekvienam tikslumo lygmeniui
  }
  rib <- filter(const, const$SE > 1)
  t.sel <- max(rib$SEi) # iÅ¡renkamas didÅ¾iausias tikslumo lygmuo, su kuriuo dar randama reikÅ¡mingÅ³ klaidÅ³
  ribos <- data.frame(duom$vs2, t.sel) # didÅ¾iausias tikslumo lygmuo kiekvienai veiklai
}
ribos2 <- do.call(rbind, by(duom, duom$vs2, band))
t_sel_pvm <- data.frame(veikla = ribos2$duom.vs2, t.sel = ifelse(ribos2$t.sel == 0, 0.001, ribos2$t.sel))
t_sel_pvm <- data.frame(unique(t_sel_pvm))


#-----SKAIÄŒIAVIMAI-----

DUOM <- 0
est1 <- 0
sel1 <- 0
issk <- 0
issk2 <- 0

for(i in 1:nrow(t_sel_pvm)) {
  DUOM[i] = list(subset(duom, duom$vs2 == t_sel_pvm$veikla[i]))
  est1[i] = ml.est(y = DUOM[[i]][,"viso"], x = DUOM[[i]][,"pvm"], eps = 0.1)
  sel1[i] = list(sel.edit(y = DUOM[[i]][,"viso"], ypred = est1[[i]][,1], t.sel = t_sel_pvm[,"t.sel"][i])[,9])
  issk[i] = list(data.frame(DUOM[[i]], t_sel_pvm$t.sel[i], sel_editing1 = sel1[[i]]))
}

isskirtys_pvm <- do.call(rbind.data.frame, issk)
isskirtys_pvm$skirt_pm = round((1-(isskirtys_pvm$pvm/isskirtys_pvm$viso))*100, 1)

```

#### 5.3. Pasinaudokite Å¾emiau esanÄiu kodo langeliu, kad apskaiÄiuotumÄ—te kiek iÅ¡skirÄiÅ³ buvo nustatyta pasirinktinio redagavimo metodu. 

```{r selective-editing2, exercise=TRUE, exercise.lines = 3, exercise.cap = "R kodas", exercise.setup = "selective-editing1-solution", exercise.timelimit = 30000}
___(isskirtys_pvm$sel_editing1)
```

```{r selective-editing2-hint}
Galite pasinaudoti funkcija count().
```

```{r selective-editing2-solution}
count(isskirtys_pvm$sel_editing1)
```

```{r quiz7, echo=FALSE, warning=FALSE}
quiz(caption = "",
  question("Kiek iÅ¡skirÄiÅ³ nustatyta naudojantis pasirinktinio redagavimo metodu?", 
           answer("197"), 
           answer("3635"),
           answer("179", correct = TRUE),
           answer("3536"),
           correct = "Atsakymas teisingas! Naudojantis pasirinktinio redagavimo metodu, nustatyta 179 iÅ¡skirtys", 
           incorrect = "Bandykite dar kartÄ…. IÅ¡skirtys, aukÅ¡Äiau pateikoje lentelÄ—je, uÅ¾koduotos 1. ",
           allow_retry = TRUE,
  submit_button = "Pateikti",
  try_again_button = "IÅ¡ naujo"
  )
)
```

```{r, echo=FALSE, out.width="50%", fig.align = "center"}
knitr::include_graphics("images/hi5.jfif")  
```

## 6. *Hidiroglou-Berthelot* metodas 
<br>

```{r, echo=FALSE, out.width="30%", fig.align = "left"}
knitr::include_graphics("images/Hidiroglou-Berthelot-method.png")  
```

<br>[Hidiroglou-Berthelot metodas](https://ssc.ca/sites/default/files/survey/documents/SSC2003_R_Belcher.pdf) buvo pasiÅ«lytas M.A.Hidiroglou ir J. M. Bertheloto (1986) periodiniams verslo statistiniams tyrimams.

Å½emiau pateikiamas kodas *Hidiroglou-Berthelot* metodui, taikytinas Ä¯moniÅ³ apyvartos iÅ¡skirtims nustatyti. SkaiÄiuosime iÅ¡skirtis `viso` kintamajam. 


#### 6.1. AtidÅ¾iai perÅ¾iÅ«rÄ—kite kodÄ…. Sekite, kur paliktos tuÅ¡Äios vietos, jas uÅ¾pildykite.


```{r HB, exercise=TRUE, exercise.cap = "R kodas",exercise.timelimit = 30000, warning=FALSE, echo=FALSE}

# Pirmiausia, atrenkami Ä¯raÅ¡ai be praleistÅ³ reikÅ¡miÅ³ ir didesni uÅ¾ 0
duom <- duomenys1[complete.cases(duomenys1$viso_prm_ket) & complete.cases(duomenys1$viso),]
duom <- duom[duom$viso_prm_ket > 0 & duom$viso > 0,]

# Surandamas kiekvienos veiklos Ä¯moniÅ³ skaiÄius pagal jÅ³ veiklos sritÄ¯
nrow_f <- function(df) length(df$viso)
nrow_df <- ddply(duom, .(vs2), nrow_f)
duom <- merge(duom, nrow_df, by = "vs2")



# Pagal straipsnyje pateikiamas rekomendacijas, veiklÅ³ grupÄ—s, kuriose yra maÅ¾iau nei 3 Ä¯monÄ—s - paÅ¡alinamos, kitos - Ä¯raÅ¡omos kaip `duom`.
nepateke2 <- duom[duom$V1 < 3,]
duom <- duom[duom$V1 >= 3,]

# Pabrauktose vietose, pervadinkite paskutinÄ¯ stulpelÄ¯ Ä¯ "grupes_dydis"
names(nepateke2)[ncol(nepateke2)] <- "______"
names(duom)[ncol(duom)] <- "______"


#----------------KIEKVIENOS VEIKLOS C PARAMETRAS--------------------------------
# Å½emiau pateikta funkcija apibrÄ—Å¾ia Hidiroglou-Berthelot metodÄ… mÅ«sÅ³ turimiems duomenims. 

HidBer <- function(duom) {
  const1 <- 0
  ataskaitinis <- duom$viso # ataskaitiniai duomenys
  ankstesnis <- duom$viso_prm_ket # istoriniai duomenys
  u <- ___ # apibrÄ—Å¾kite 'u' konstantÄ… 0.4
  A <- ___ # apibrÄ—Å¾kite 'A' konstantÄ… kaip apraaÅ¡yta mokymÅ³ skaidrÄ—se (Hidiroglou-Berthelot metodas (IV)
  for (i in 1:500) {
    R <- ataskaitinis/ankstesnis # Kiekvienam stebimam populiacijos elementui ğ‘– apibrÄ—Å¾iame individualÅ³ santykinÄ¯ pokytÄ¯
    m <- median(R) # Tegu $ğ‘…_ğ‘€$ â€“ santykiniÅ³ pokyÄiÅ³ $ğ‘…_ğ‘–$ mediana
    S <- ifelse(R > 0 & R < m, (1-(m/R)), ifelse(R >= m, ((R/m)-1), 0)) # Taikoma $ğ‘…_ğ‘–4 transformacija
    E <- S*(max(ataskaitinis, ankstesnis)^u)
    Em <- median(E)
    Eq1 <- quantile(E, prob = 0.25, type = 2)
    Eq3 <- quantile(E, prob = 0.75, type = 2)
    Dq1 <- max(Em-Eq1, abs(A*Em))
    Dq3 <- max(Eq3-Em, abs(A*Em))
    C <- i
    ap_r <- Em-C*Dq1
    virs_r <- Em+C*Dq3
    H_B1 <- data.frame(HB = ifelse(E < ap_r | E > virs_r, 1, 0))
    HB <- sum(H_B1$HB) # iÅ¡skirÄiÅ³ skaiÄius
    proc <- round(HB/length(ankstesnis)*100, digits = 2) # iÅ¡skirÄiÅ³ procentinÄ— dalis
    const1 = rbind(const1, data.frame(C, HB, proc)) # iÅ¡skirÄiÅ³ skaiÄius skirtingiems C
  }
  # rib1 <- filter(const1, const1$proc < 10 & const1$proc > 5) # iÅ¡skirÄiÅ³ proc. dalis tarp 5 ir 10
  rib1 <- const1[const1$proc < 10 & const1$proc > 5,] # iÅ¡skirÄiÅ³ proc. dalis tarp 5 ir 10
  c <- max(rib1$C) # iÅ¡renkamas didÅ¾iausias C, su kuriuo dar randama reikÅ¡mingÅ³ klaidÅ³
  ribos_hb <- data.frame(duom$vs2, c) # didÅ¾iausias C kiekvienai veiklai
}

ribos_HB <- do.call(rbind, by(duom, duom$vs2, HidBer))
# c_aut <- filter(ribos_HB, ribos_HB$c > 0)
c_aut <- ribos_HB[ribos_HB$c > 0,] # c mediana - pasisalini kurios lygios nuliui
aut <- median(c_aut$c)
C <- data.frame(veikla = ribos_HB$duom.vs2, C = ifelse(ribos_HB$c == '-Inf', aut, ribos_HB$c))
C <- data.frame(unique(C))


#-----SKAIÄŒIAVIMAI-----

DUOM2 <- 0
ataskaitinis <- 0
ankstesnis <- 0
R <- 0
m <- 0
S <- 0
E <- 0
Em <- 0
Eq1 <- 0
Eq3 <- 0
Dq1 <- 0
Dq3 <- 0
C_p <- 0
ap_r <- 0
virs_r <- 0
H_B1 <- 0
u <- 0.4
A <- 0.05

for (i in 1:nrow(C)) {
  DUOM2[i] = list(subset(duom, duom$vs2 == C$veikla[i]))
  ataskaitinis[i] <- list(DUOM2[[i]][,"viso"])
  ankstesnis[i] <- list(DUOM2[[i]][,"viso_prm_ket"])
  R[i] <- list(ataskaitinis[[i]]/ankstesnis[[i]])
  m[i] <- list(median(R[[i]]))
  S[i] <- list(ifelse(R[[i]] > 0 & R[[i]] < m[[i]], (1-(m[[i]]/R[[i]])),
                      ifelse(R[[i]] >= m[[i]], ((R[[i]]/m[[i]])-1), 0)))
  E[i] <- list(S[[i]]*(max(ataskaitinis[[i]], ankstesnis[[i]])^u))
  Em[i] <- list(median(E[[i]]))
  Eq1[i] <- list(quantile(E[[i]], prob = 0.25, type = 2))
  Eq3[i] <- list(quantile(E[[i]], prob = 0.75, type = 2))
  Dq1[i] <- list(max(Em[[i]]-Eq1[[i]], abs(A*Em[[i]])))
  Dq3[i] <- list(max(Eq3[[i]]-Em[[i]], abs(A*Em[[i]])))
  C_p[i] <- C[,"C"][i]
  ap_r[i] <- list(Em[[i]]-C_p[[i]]*Dq1[[i]])
  virs_r[i] <- list(Em[[i]]+C_p[[i]]*Dq3[[i]])
  H_B1[i] <- list(data.frame(DUOM2[[i]], C = C_p[[i]], HB = ifelse(E[[i]] < ap_r[[i]] | E[[i]] > virs_r[[i]], 1, 0)))
}

isskirtys_HB1 <- do.call(rbind.data.frame, H_B1)
isskirtys_HB1$skirt_HB1 = round((1-(isskirtys_HB1$viso_prm_ket/isskirtys_HB1$viso))*100, 1)


count(isskirtys_HB1$HB)
```

```{r HB-hint-1}
NepamirÅ¡kite Ä¯raÅ¡yti visas praleistas reikÅ¡mes, Ä¯skaitant u = 0.4, A = 0.05 (kaip nurodyta mokymÅ³ skaidrÄ—se).
```

```{r HB-hint-2}


# Atrenkami Ä¯raÅ¡ai be praleistÅ³ reikÅ¡miÅ³ ir didesni uÅ¾ 0
duom <- duomenys1[complete.cases(duomenys1$viso_prm_ket) & complete.cases(duomenys1$viso),]
duom <- duom[duom$viso_prm_ket > 0 & duom$viso > 0,]

# Surandamas kiekvienos veiklos Ä¯moniÅ³ skaiÄius
#pagal veikla
nrow_f <- function(df) length(df$viso)
nrow_df <- ddply(duom, .(vs2), nrow_f)
duom <- merge(duom, nrow_df, by = "vs2")


# Matematinis metodas bus taikomas veiklÅ³ grupÄ—ms, kuriose yra bent 3 Ä¯monÄ—s
nepateke2 <- duom[duom$V1 < 3,]
nepateke2 <- nepateke2[,c(2,1,3:ncol(nepateke2))]
names(nepateke2)[ncol(nepateke2)] <- "Grupes_dydis"

duom <- duom[duom$V1 >= 3,]
names(duom)[ncol(duom)] <- "Grupes_dydis"


#-----KIEKVIENOS VEIKLOS C PARAMETRAS-----

HidBer <- function(duom) {
  const1 <- 0
  ataskaitinis <- duom$viso
  ankstesnis <- duom$viso_prm_ket # istoriniai duomenys
  u <- 0.4 # kostantos 
  A <- 0.05
  for (i in 1:500) {
    R <- ataskaitinis/ankstesnis
    m <- median(R)
    S <- ifelse(R > 0 & R < m, (1-(m/R)), ifelse(R >= m, ((R/m)-1), 0))
    E <- S*(max(ataskaitinis, ankstesnis)^u)
    Em <- median(E)
    Eq1 <- quantile(E, prob = 0.25, type = 2)
    Eq3 <- quantile(E, prob = 0.75, type = 2)
    Dq1 <- max(Em-Eq1, abs(A*Em))
    Dq3 <- max(Eq3-Em, abs(A*Em))
    C <- i
    ap_r <- Em-C*Dq1
    virs_r <- Em+C*Dq3
    H_B1 <- data.frame(HB = ifelse(E < ap_r | E > virs_r, 1, 0))
    HB <- sum(H_B1$HB) # iÅ¡skirÄiÅ³ skaiÄius
    proc <- round(HB/length(ankstesnis)*100, digits = 2) # iÅ¡skirÄiÅ³ procentinÄ— dalis
    const1 = rbind(const1, data.frame(C, HB, proc)) # iÅ¡skirÄiÅ³ skaiÄius skirtingiems C
  }
  # rib1 <- filter(const1, const1$proc < 10 & const1$proc > 5) # iÅ¡skirÄiÅ³ proc. dalis tarp 5 ir 10
  rib1 <- const1[const1$proc < 10 & const1$proc > 5,] # iÅ¡skirÄiÅ³ proc. dalis tarp 5 ir 10
  c <- max(rib1$C) # iÅ¡renkamas didÅ¾iausias C, su kuriuo dar randama reikÅ¡mingÅ³ klaidÅ³
  ribos_hb <- data.frame(duom$vs2, c) # didÅ¾iausias C kiekvienai veiklai
}

ribos_HB <- do.call(rbind, by(duom, duom$vs2, HidBer))
# c_aut <- filter(ribos_HB, ribos_HB$c > 0)
c_aut <- ribos_HB[ribos_HB$c > 0,] # c mediana - pasisalini kurios lygios nuliui
aut <- median(c_aut$c)
C <- data.frame(veikla = ribos_HB$duom.vs2, C = ifelse(ribos_HB$c == '-Inf', aut, ribos_HB$c))
C <- data.frame(unique(C))


#-----SKAIÄŒIAVIMAI-----

DUOM2 <- 0
ataskaitinis <- 0
ankstesnis <- 0
R <- 0
m <- 0
S <- 0
E <- 0
Em <- 0
Eq1 <- 0
Eq3 <- 0
Dq1 <- 0
Dq3 <- 0
C_p <- 0
ap_r <- 0
virs_r <- 0
H_B1 <- 0
u <- 0.4
A <- 0.05

for (i in 1:nrow(C)) {
  DUOM2[i] = list(subset(duom, duom$vs2 == C$veikla[i]))
  ataskaitinis[i] <- list(DUOM2[[i]][,"viso"])
  ankstesnis[i] <- list(DUOM2[[i]][,"viso_prm_ket"])
  R[i] <- list(ataskaitinis[[i]]/ankstesnis[[i]])
  m[i] <- list(median(R[[i]]))
  S[i] <- list(ifelse(R[[i]] > 0 & R[[i]] < m[[i]], (1-(m[[i]]/R[[i]])),
                      ifelse(R[[i]] >= m[[i]], ((R[[i]]/m[[i]])-1), 0)))
  E[i] <- list(S[[i]]*(max(ataskaitinis[[i]], ankstesnis[[i]])^u))
  Em[i] <- list(median(E[[i]]))
  Eq1[i] <- list(quantile(E[[i]], prob = 0.25, type = 2))
  Eq3[i] <- list(quantile(E[[i]], prob = 0.75, type = 2))
  Dq1[i] <- list(max(Em[[i]]-Eq1[[i]], abs(A*Em[[i]])))
  Dq3[i] <- list(max(Eq3[[i]]-Em[[i]], abs(A*Em[[i]])))
  C_p[i] <- C[,"C"][i]
  ap_r[i] <- list(Em[[i]]-C_p[[i]]*Dq1[[i]])
  virs_r[i] <- list(Em[[i]]+C_p[[i]]*Dq3[[i]])
  H_B1[i] <- list(data.frame(DUOM2[[i]], C = C_p[[i]], HB = ifelse(E[[i]] < ap_r[[i]] | E[[i]] > virs_r[[i]], 1, 0)))
}

isskirtys_HB1 <- do.call(rbind.data.frame, H_B1)
isskirtys_HB1$skirt_HB1 = round((1-(isskirtys_HB1$viso_prm_ket/isskirtys_HB1$viso))*100, 1)
```

```{r HB-solution}


# Atrenkami Ä¯raÅ¡ai be praleistÅ³ reikÅ¡miÅ³ ir didesni uÅ¾ 0
duom <- duomenys1[complete.cases(duomenys1$viso_prm_ket) & complete.cases(duomenys1$viso),]
duom <- duom[duom$viso_prm_ket > 0 & duom$viso > 0,]

# Surandamas kiekvienos veiklos Ä¯moniÅ³ skaiÄius
#pagal veikla
nrow_f <- function(df) length(df$viso)
nrow_df <- ddply(duom, .(vs2), nrow_f)
duom <- merge(duom, nrow_df, by = "vs2")


# Matematinis metodas bus taikomas veiklÅ³ grupÄ—ms, kuriose yra bent 3 Ä¯monÄ—s
nepateke2 <- duom[duom$V1 < 3,]
nepateke2 <- nepateke2[,c(2,1,3:ncol(nepateke2))]
names(nepateke2)[ncol(nepateke2)] <- "Grupes_dydis"

duom <- duom[duom$V1 >= 3,]
names(duom)[ncol(duom)] <- "Grupes_dydis"


#-----KIEKVIENOS VEIKLOS C PARAMETRAS-----

HidBer <- function(duom) {
  const1 <- 0
  ataskaitinis <- duom$viso
  ankstesnis <- duom$viso_prm_ket # istoriniai duomenys
  u <- 0.4 # kostantos 
  A <- 0.05
  for (i in 1:500) {
    R <- ataskaitinis/ankstesnis
    m <- median(R)
    S <- ifelse(R > 0 & R < m, (1-(m/R)), ifelse(R >= m, ((R/m)-1), 0))
    E <- S*(max(ataskaitinis, ankstesnis)^u)
    Em <- median(E)
    Eq1 <- quantile(E, prob = 0.25, type = 2)
    Eq3 <- quantile(E, prob = 0.75, type = 2)
    Dq1 <- max(Em-Eq1, abs(A*Em))
    Dq3 <- max(Eq3-Em, abs(A*Em))
    C <- i
    ap_r <- Em-C*Dq1
    virs_r <- Em+C*Dq3
    H_B1 <- data.frame(HB = ifelse(E < ap_r | E > virs_r, 1, 0))
    HB <- sum(H_B1$HB) # iÅ¡skirÄiÅ³ skaiÄius
    proc <- round(HB/length(ankstesnis)*100, digits = 2) # iÅ¡skirÄiÅ³ procentinÄ— dalis
    const1 = rbind(const1, data.frame(C, HB, proc)) # iÅ¡skirÄiÅ³ skaiÄius skirtingiems C
  }
  # rib1 <- filter(const1, const1$proc < 10 & const1$proc > 5) # iÅ¡skirÄiÅ³ proc. dalis tarp 5 ir 10
  rib1 <- const1[const1$proc < 10 & const1$proc > 5,] # iÅ¡skirÄiÅ³ proc. dalis tarp 5 ir 10
  c <- max(rib1$C) # iÅ¡renkamas didÅ¾iausias C, su kuriuo dar randama reikÅ¡mingÅ³ klaidÅ³
  ribos_hb <- data.frame(duom$vs2, c) # didÅ¾iausias C kiekvienai veiklai
}

ribos_HB <- do.call(rbind, by(duom, duom$vs2, HidBer))
# c_aut <- filter(ribos_HB, ribos_HB$c > 0)
c_aut <- ribos_HB[ribos_HB$c > 0,] # c mediana - pasisalini kurios lygios nuliui
aut <- median(c_aut$c)
C <- data.frame(veikla = ribos_HB$duom.vs2, C = ifelse(ribos_HB$c == '-Inf', aut, ribos_HB$c))
C <- data.frame(unique(C))


#-----SKAIÄŒIAVIMAI-----

DUOM2 <- 0
ataskaitinis <- 0
ankstesnis <- 0
R <- 0
m <- 0
S <- 0
E <- 0
Em <- 0
Eq1 <- 0
Eq3 <- 0
Dq1 <- 0
Dq3 <- 0
C_p <- 0
ap_r <- 0
virs_r <- 0
H_B1 <- 0
u <- 0.4
A <- 0.05

for (i in 1:nrow(C)) {
  DUOM2[i] = list(subset(duom, duom$vs2 == C$veikla[i]))
  ataskaitinis[i] <- list(DUOM2[[i]][,"viso"])
  ankstesnis[i] <- list(DUOM2[[i]][,"viso_prm_ket"])
  R[i] <- list(ataskaitinis[[i]]/ankstesnis[[i]])
  m[i] <- list(median(R[[i]]))
  S[i] <- list(ifelse(R[[i]] > 0 & R[[i]] < m[[i]], (1-(m[[i]]/R[[i]])),
                      ifelse(R[[i]] >= m[[i]], ((R[[i]]/m[[i]])-1), 0)))
  E[i] <- list(S[[i]]*(max(ataskaitinis[[i]], ankstesnis[[i]])^u))
  Em[i] <- list(median(E[[i]]))
  Eq1[i] <- list(quantile(E[[i]], prob = 0.25, type = 2))
  Eq3[i] <- list(quantile(E[[i]], prob = 0.75, type = 2))
  Dq1[i] <- list(max(Em[[i]]-Eq1[[i]], abs(A*Em[[i]])))
  Dq3[i] <- list(max(Eq3[[i]]-Em[[i]], abs(A*Em[[i]])))
  C_p[i] <- C[,"C"][i]
  ap_r[i] <- list(Em[[i]]-C_p[[i]]*Dq1[[i]])
  virs_r[i] <- list(Em[[i]]+C_p[[i]]*Dq3[[i]])
  H_B1[i] <- list(data.frame(DUOM2[[i]], C = C_p[[i]], HB = ifelse(E[[i]] < ap_r[[i]] | E[[i]] > virs_r[[i]], 1, 0)))
}

isskirtys_HB1 <- do.call(rbind.data.frame, H_B1)
isskirtys_HB1$skirt_HB1 = round((1-(isskirtys_HB1$viso_prm_ket/isskirtys_HB1$viso))*100, 1)
```


#### 6.2. Pasinaudokite Å¾emiau esanÄiu kodo langeliu, kad apskaiÄiuotumÄ—te kiek iÅ¡skirÄiÅ³ buvo nustatyta Hidiroglou-Berthelot metodu. 

```{r HB2, exercise=TRUE, exercise.lines = 3, exercise.cap = "R kodas", exercise.setup = "HB-solution", exercise.timelimit = 30000}
___(isskirtys_HB1$HB)
```

```{r HB2-hint}
Galite pasinaudoti funkcija count().
```

```{r HB2-solution}
count(isskirtys_HB1$HB)
```

```{r quiz8, echo=FALSE, warning=FALSE}
quiz(caption = "",
  question("Kiek iÅ¡skirÄiÅ³ nustatyta?", 
           answer("168", correct = TRUE), 
           answer("2536"),
           answer("167"),
           answer("2356"),
           correct = "Atsakymas teisingas! Naudojantis Hidiroglou-Berthelot metodu, nustatyta 168 iÅ¡skirtys", 
           incorrect = "Bandykite dar kartÄ…. IÅ¡skirtys, aukÅ¡Äiau pateikoje lentelÄ—je, uÅ¾koduotos 0. ",
           allow_retry = TRUE,
  submit_button = "Pateikti",
  try_again_button = "IÅ¡ naujo"
  )
)
```

#### 6.3. Tyrimo tikslas - nustatyti, kaip paaugo Ä¯moniÅ³ apyvarta per pastarÄ…jÄ¯ ketvirtÄ¯. Kaip papildomus duomenis, turime praÄ—jusiÅ³ metÅ³ to paties ketvirÄio apyvartos duomenis. 

```{r quiz9, warning=FALSE, echo=FALSE}
question_checkbox(
"KokÄ¯ iÅ¡skirÄiÅ³ nustatymo bÅ«dÄ… naudosite apraÅ¡ytam atvejui?",
answer("*Hidiroglou-Berthelot* metodÄ…", correct = TRUE),
answer("Pasirinktinio redagavimo metodÄ…"),
answer("Lokalaus tikslo funkcijÄ…"),
answer("LiekamÄ…jÄ… santykinÄ™ paklaidÄ…"),
    random_answer_order = TRUE,
    allow_retry = TRUE,
    try_again = "Bandykite iÅ¡ naujo. TurÄ—kite omenyje, kad esama istoriniÅ³ duomenÅ³, kurie gali bÅ«ti naudojami viename iÅ¡ Å¡iÅ³ metodÅ³. Pasikartokite teorines Å¾inias mokymÅ³ skaidrÄ—se.",
    submit_button = "Pateikti",
    try_again_button = "IÅ¡ naujo",
    correct = "Atsakymas teisingas! Kadangi esama istoriniÅ³ Ä¯monÄ—s duomenÅ³ apie PVM, renkamÄ—s *Hidiroglou-Berthelot* metodÄ….", 
    incorrect = "Bandykite dar kartÄ…."
)
```

```{r, echo=FALSE, out.width="50%", fig.align = "center"}
knitr::include_graphics("images/error.jpg")  
```

```{r, echo=FALSE, out.width="10%", fig.align = "right"}
knitr::include_graphics("images/learnr.png")  
```